/*import java.util.*;

class Node {
    int value;
    Node left, right;

    Node(int value) {
        this.value = value;
        left = right = null;
    }
}

class BST {
    Node root;

    public void insert(int value) {
        root = insertRec(root, value);
    }

    private Node insertRec(Node root, int value) {
        if (root == null) {
            return new Node(value);
        }
        if (value < root.value)
            root.left = insertRec(root.left, value);
        else
            root.right = insertRec(root.right, value);

        return root;
    }

    public void delete(int value) {
        root = deleteRec(root, value);
    }

    private Node deleteRec(Node root, int value) {
        if (root == null)
            return null;

        if (value < root.value) {
            root.left = deleteRec(root.left, value);
        }
        else if (value > root.value) {
            root.right = deleteRec(root.right, value);
        }
        else {
            if (root.left == null && root.right == null)
                return null;

            if (root.left == null)
                return root.right;

            if (root.right == null)
                return root.left;

            int successorValue = findMin(root.right);
            root.value = successorValue;
            root.right = deleteRec(root.right, successorValue);
        }
        return root;
    }

    private int findMin(Node root) {
        while (root.left != null)
            root = root.left;
        return root.value;
    }

    public int countNodes() {
        return countNodesRec(root);
    }

    private int countNodesRec(Node root) {
        if (root == null) return 0;
        return 1 + countNodesRec(root.left) + countNodesRec(root.right);
    }

    public int countLeafNodes() {
        return countLeafNodesRec(root);
    }

    private int countLeafNodesRec(Node root) {
        if (root == null) return 0;
        if (root.left == null && root.right == null) return 1;
        return countLeafNodesRec(root.left) + countLeafNodesRec(root.right);
    }

    public boolean isValidBST() {
        return isValidBSTRec(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }

    private boolean isValidBSTRec(Node root, int min, int max) {
        if (root == null) return true;
        if (root.value <= min || root.value >= max) return false;
        return isValidBSTRec(root.left, min, root.value) &&
               isValidBSTRec(root.right, root.value, max);
    }

    public void levelOrderTraversal() {
        if (root == null) return;
        Queue<Node> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {
            Node curr = q.poll();
            System.out.print(curr.value + " ");
            if (curr.left != null) q.add(curr.left);
            if (curr.right != null) q.add(curr.right);
        }
        System.out.println();
    }
}

public class code14 {
    public static void main(String[] args) {
        BST tree = new BST();

        tree.insert(50);
        tree.insert(30);
        tree.insert(70);
        tree.insert(20);
        tree.insert(40);
        tree.insert(60);
        tree.insert(80);

        System.out.println("Total Nodes: " + tree.countNodes());
        System.out.println("Leaf Nodes: " + tree.countLeafNodes());
        System.out.println("Valid BST: " + tree.isValidBST());

        System.out.println("Level Order Traversal:");
        tree.levelOrderTraversal();

        tree.delete(50);
        System.out.println("After Deleting 50:");
        tree.levelOrderTraversal();
    }
}

*/
